#!/bin/bash
# shpm : Main command for shellkit-pm

canonpath() {
    type -t realpath.sh &>/dev/null && {
        realpath.sh -f "$@"
        return
    }
    # Ok for rough work only.  Prefer realpath.sh if it's on the path.
    ( cd -L -- "$(dirname -- $0)"; echo "$(pwd -P)/$(basename -- $0)" )
}

[[ -z ${scriptName} ]] && scriptName="$(canonpath $0)"
[[ -z ${scriptDir} ]] && scriptDir=$(command dirname -- "${scriptName}")

die() {
    builtin echo "ERROR: $*" >&2
    builtin exit 1
}



stub() {
   builtin echo "  <<< STUB[$*] >>> " >&2
}

unimplemented() {
    echo "Unimplemented feature: $*" >&2
    exit 1
}



_print_package_status() {
    # When:
    #   $1 = package name
    # Then:
    #   print [pkg_name] [installed?] [version]  // and return 0 if valid  package name
    #   print err // and return 1 if not valid package name
    local pkgName="$1"
    shellkit-query-package.sh "$pkgName" || return
    echo -n "$pkgName "
    local detectCmd=$(shellkit-query-package.sh "$pkgName" detect-command)
    [[ -n $detectCmd ]] || {
        echo "ERROR: no detect-command property for ${pkgName} in config";
        false; return;
    }
    (
        ${detectCmd} | tr '\n' ' '
        [[ ${PIPESTATUS[0]} -eq 0 ]]
    ) || {
        echo "   -> Failed detecting ${pkgName}, but this could be installed with \"shpm install ${pkgName}\"" >&2;
        false;
        return;
    }
}

status() {
    # Print the status of given package(s).  If any package fails,
    # result is non-zero.  Format is:
    #  [index] [package-name] [package-status]
    #  ...or...
    #  [index] ERROR <package-undefined msg>
    [[ $# == 0 ]] && die "No package name(s) provided to status command"
    local result=0
    local index=0
    for pkg_name; do
        echo -n "$(( index++ )) "
        _print_package_status $pkg_name 2>&1  | tr '\n' ' '
        [[ ${PIPESTATUS[0]} -eq 0 ]] || result=1
        echo
    done
    [[ $result -eq  0 ]]
}

_query_package_property() {
    ${scriptDir}/shellkit-query-package.sh "$@"
}

config() {
    local cfgPath=$(_find_config)
    [[ -n $cfgPath ]] || die 101
    echo "# Config-found: ${cfgPath}"
    echo "# Content of packages metadata follows:"
    echo "---------------------------------------"
    cat "${cfgPath}"
}

config-prop() {
    local _f=config-prop
    _query_package_property "$@" || die "$_f.1"
}

list() {
    local cfgPath=$(_find_config)
    [[ -n $cfgPath ]] || die 101
    while read kitname _; do
        local detect_result="$(_detect_package ${kitname})" 2>/dev/null
        echo -n "${kitname} "
        [[ -n $detect_result ]] && { echo "$detect_result"; } || { echo " --> not installed"; }
        (
            shellkit-query-package.sh ${kitname} desc
            shellkit-query-package.sh ${kitname} canon-source
        ) | command sed 's/^/   /'
    done < <( command grep -Eo '^[-_a-z0-9]+\s' ${cfgPath} | command uniq ; )
}

install() {
    ${scriptDir}/install-package.sh "$@"
}

parseArgs() {
    [[ -z $1 ]] && {
        shellkit-pm-help "${scriptName}"
        exit
    }
    while [[ -n $1 ]]; do
        case $1 in
            --help)
                shift
                shellkit-pm-help "${scriptName}"
                exit
                ;;
            --version)
                #help Print version info for shellkit-pm
                shift
                shellkit-pm-version.sh "$@"
                exit
                ;;
            install)
                #help Install [package [package...]]
                shift
                install "$@"
                exit
                ;;
            uninstall)
                shift
                unimplemented "$*"
                ;;
            update)
                shift
                unimplemented "$*"
                ;;
            status)
                #help Print status of [package [package...]]
                shift
                status "$@"
                exit
                ;;
            list)
                #help List package catalog with installation status
                shift
                list "$@"
                ;;
            config)
                shift
                config "$@"
                exit
                ;;
            config-prop)
                shift
                config-prop "$@"
                exit
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
        shift
    done
}

main() {
    parseArgs "$@"
}

[[ -z ${sourceMe} ]] && {
    parseArgs "$@"
    exit
}

true
