#!/bin/bash
# shpm : Main command for shellkit-pm

canonpath() {
    type -t realpath.sh &>/dev/null && {
        realpath.sh -f "$@"
        return
    }
    # Ok for rough work only.  Prefer realpath.sh if it's on the path.
    ( cd -L -- "$(dirname -- $0)"; echo "$(pwd -P)/$(basename -- $0)" )
}

[[ -z ${scriptName} ]] && scriptName="$(canonpath $0)"
[[ -z ${scriptDir} ]] && scriptDir=$(command dirname -- "${scriptName}")

die() {
    builtin echo "ERROR: $*" >&2
    builtin exit 1
}



stub() {
   builtin echo "  <<< STUB[$*] >>> " >&2
}

unimplemented() {
    echo "Unimplemented feature: $*" >&2
    exit 1
}


_find_config() {
    [[ -n ${SHELLKIT_META_DIR} ]] && {
        [[ -f ${SHELLKIT_META_DIR}/packages ]] || die "Can't find 'packages' in \$SHELLKIT_META_DIR ($SHELLKIT_META_DIR)"
        echo ${SHELLKIT_META_DIR}/packages
        return
    }
    local searchList=("~/.config/shellkit-meta/packages" "/test_dir/packages")
    for path in "${searchList[@]}"; do
        path=$(eval "echo $path")
        [[ -f ${path} ]] && {
            echo "$(canonpath ${path})"
            return
        }
    done
    echo "ERROR: Can't find metadata in: ${searchList[@]}" >&2
}

_query_package_property() {
    # ---  Case 1 ---
    # When:
    #  $1 = package name
    #  $2 <not provided>
    #
    # Then:
    #  - print 'ok' if any property exists for given package name
    #  - return 0 if any property is defined, else non-zero
    #  - print err on fail
    #
    # ---  Case 2 ---
    # When:
    #  $1 = package name
    #  $2 = packages record-type
    # Then:
    #  - print value of given property from packages metadata
    #  - return 0 if property was defined, else non-zero
    #  - print err if package not valid
    local cfgPath=$(_find_config)
    local packageName="$1"
    local recordType="$2"
    [[ -n $2 ]] && {
        read _ __ propertyValue < <(command grep -E "^${packageName}\s*${recordType}\s*" "${cfgPath}")
        local res=$?
        echo "${propertyValue}"
        [[ $res -eq 0 ]]; return
    } || {
        # No record-type, so just test for package name validity:
        [[ -n $1 ]] || die "No package-name \$1 passed to _query_package_property"
        command grep -Eq "^${packageName}\s*" "${cfgPath}" &>/dev/null
        [[ $? -eq  0 ]] || {
            echo "ERROR: invalid package name \"${packageName}\": not defined in ${cfgPath}" >&2
            false; return;
        }
        return
    }
}

_detect_package() {
    local pkgName="$1"
    local detectCmd=$(_query_package_property "$pkgName" detect-command)
    [[ -n ${detectCmd} ]] || return
    ${detectCmd} 2>/dev/null
}

_print_package_status() {
    # When:
    #   $1 = package name
    # Then:
    #   print [pkg_name] [installed?] [version]  // and return 0 if valid  package name
    #   print err // and return 1 if not valid package name
    local pkgName="$1"
    _query_package_property "$pkgName" || return
    echo -n "$pkgName "
    local detectCmd=$(_query_package_property "$pkgName" detect-command)
    [[ -n $detectCmd ]] || {
        echo "ERROR: no detect-command property for ${pkgName} in config";
        false; return;
    }
    (
        ${detectCmd} | tr '\n' ' '
        [[ ${PIPESTATUS[0]} -eq 0 ]]
    ) || {
        echo "   -> Failed detecting ${pkgName}, but this could be installed with \"shpm install ${pkgName}\"" >&2;
        false;
        return;
    }
}

status() {
    # Print the status of given package(s).  If any package fails,
    # result is non-zero.  Format is:
    #  [index] [package-name] [package-status]
    #  ...or...
    #  [index] ERROR <package-undefined msg>
    [[ $# == 0 ]] && die "No package name(s) provided to status command"
    local result=0
    local index=0
    for pkg_name; do
        echo -n "$(( index++ )) "
        _print_package_status $pkg_name 2>&1  | tr '\n' ' '
        [[ ${PIPESTATUS[0]} -eq 0 ]] || result=1
        echo
    done
    [[ $result -eq  0 ]]
}

config() {
    local cfgPath=$(_find_config)
    [[ -n $cfgPath ]] || die 101
    echo "# Config-found: ${cfgPath}"
    echo "# Content of packages metadata follows:"
    echo "---------------------------------------"
    cat "${cfgPath}"
}

config-prop() {
    local cfgPath=$(_find_config)
    [[ -n $cfgPath ]] || die 101
    _query_package_property "$1" $2 || die "Error finding property $1:$2"
}

list() {
    local cfgPath=$(_find_config)
    [[ -n $cfgPath ]] || die 101
    while read kitname _; do
        local detect_result="$(_detect_package ${kitname})" 2>/dev/null
        echo -n "${kitname} "
        [[ -n $detect_result ]] && { echo "$detect_result"; } || { echo " --> not installed"; }
        (
            _query_package_property ${kitname} desc
            _query_package_property ${kitname} canon-source
        ) | command sed 's/^/   /'
    done < <( command grep -Eo '^[-_a-z0-9]+\s' ${cfgPath} | command uniq ; )
}

install() {
    ${scriptDir}/install-package.sh "$@"
}

parseArgs() {
    [[ -z $1 ]] && {
        shellkit-pm-help "${scriptName}"
        exit
    }
    while [[ -n $1 ]]; do
        case $1 in
            --help)
                shift
                shellkit-pm-help "${scriptName}"
                exit
                ;;
            --version)
                #help Print version info for shellkit-pm
                shift
                shellkit-pm-version.sh "$@"
                exit
                ;;
            install)
                #help Install [package [package...]]
                shift
                install "$@"
                exit
                ;;
            uninstall)
                shift
                unimplemented "$*"
                ;;
            update)
                shift
                unimplemented "$*"
                ;;
            status)
                #help Print status of [package [package...]]
                shift
                status "$@"
                exit
                ;;
            list)
                #help List package catalog with installation status
                shift
                list "$@"
                ;;
            config)
                shift
                config "$@"
                exit
                ;;
            config-prop)
                shift
                config-prop "$@"
                exit
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
        shift
    done
}

main() {
    parseArgs "$@"
}

[[ -z ${sourceMe} ]] && {
    parseArgs "$@"
    exit
}

true
